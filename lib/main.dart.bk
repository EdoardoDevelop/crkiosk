import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:kiosk_mode/kiosk_mode.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart';

void main() {
  runApp(const App());
}

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) => MaterialApp(
    home: const HomeLauncherScreen(),
    debugShowCheckedModeBanner: false,
  );
}

class HomeLauncherScreen extends StatefulWidget {
  const HomeLauncherScreen({super.key});

  @override
  State<HomeLauncherScreen> createState() => _HomeLauncherScreenState();
}

class _HomeLauncherScreenState extends State<HomeLauncherScreen> {
  late final WebViewController _webViewController;
  bool _isWebViewInitialized = false;
  final storage = const FlutterSecureStorage();
  String _urlHome = "https://www.google.com";
  String? _correctPassword;
  bool _isWebViewLoading = true;
  HttpServer? _server;
  String _serverIp = 'Indirizzo IP non disponibile';
  int _serverPort = 3636;
  String _lastCommand = 'Nessun comando ricevuto';
  DateTime? _lastCommandTime;
  bool _isLauncherDefault = false;
  bool _showPanel = false;
  String? _deviceId;
  List<String> _logs = [];

  @override
  void initState() {
    super.initState();
    _setupLauncher();
    _loadUrlHome().then((_) {
      _initWebView();
      setState(() {
        _isWebViewInitialized = true;
      });
      return _startHttpServer();
    }).catchError((error) {
      _addLog("Error during initialization: $error");
      setState(() {
        _isWebViewInitialized = false;
      });
    });
    _getLocalIp();
    _loadPassword();
    _checkDefaultLauncher();
  }

  void _addLog(String message) {
    final now = DateTime.now().toLocal();
    final formattedMessage = '[${now.hour}:${now.minute}:${now.second}] $message';

    setState(() {
      _logs.add(formattedMessage);
      // Manteniamo solo gli ultimi N log per evitare di consumare troppa memoria
      if (_logs.length > 50) {
        _logs.removeAt(0);
      }
    });
  }

  Future<void> _setupLauncher() async {
    if (Platform.isAndroid) {
      // Imposta la modalità immersive
      await SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

      // Disabilita i pulsanti di sistema
      await SystemChrome.setEnabledSystemUIMode(
        SystemUiMode.immersiveSticky,
        overlays: [],
      );
    }
  }

  Future<void> _checkDefaultLauncher() async {
    if (Platform.isAndroid) {
      try {
        // Questo è un modo semplificato per verificare se siamo il launcher predefinito
        // Nota: non esiste un modo diretto per verificarlo, questa è un'approssimazione
        final isHome = await const MethodChannel('flutter.launcher').invokeMethod('isHomeApp');
        setState(() {
          _isLauncherDefault = isHome == true;
        });
      } catch (e) {
        if (kDebugMode) {
          print("Errore nel verificare lo stato del launcher: $e");
        }
      }
    }
  }

  Future<void> _loadUrlHome() async {
    final storedUrl = await storage.read(key: 'urlHome');
    if (storedUrl != null && storedUrl.isNotEmpty) {
      setState(() {
        _urlHome = storedUrl;
      });
    }
    _addLog("URL Home caricato: $_urlHome");
  }

  Future<void> _loadPassword() async {
    _correctPassword = await storage.read(key: 'password');
    if (_correctPassword == null) {
      _correctPassword = "123456";
    }
  }

  void _initWebView() {
    _webViewController = WebViewController()
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setNavigationDelegate(
        NavigationDelegate(
          onPageStarted: (url) => setState(() => _isWebViewLoading = true),
          onPageFinished: (url) => setState(() => _isWebViewLoading = false),
          onWebResourceError: (error) {
            _addLog("WebView Error: ${error.description}");
          },
        ),
      )
      ..loadRequest(Uri.parse(_urlHome));
    _addLog("WebView initializzato con URL: $_urlHome");
  }

  Future<void> _getLocalIp() async {
    try {
      final interfaces = await NetworkInterface.list();
      for (var interface in interfaces) {
        for (var addr in interface.addresses) {
          if (addr.type == InternetAddressType.IPv4 && !addr.isLoopback) {
            setState(() => _serverIp = addr.address);
            return;
          }
        }
      }
    } catch (e) {
      _addLog('Errore nel recupero IP: $e');
    }
  }

  Future<void> _startHttpServer() async {
    handler(Request request) async {
      if (request.method == 'OPTIONS') {
        return Response.ok(
          '',
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Origin, Content-Type',
          },
        );
      }

      final command = request.url.pathSegments.last;
      final now = DateTime.now();

      setState(() {
        _lastCommand = command;
        _lastCommandTime = now;
      });

      String responseMessage;

      try {
        if (command == 'reload') {
          _webViewController.reload();
          responseMessage = 'Pagina ricaricata con successo';
        } else if (command == 'go-home') {
          await _webViewController.loadRequest(Uri.parse(_urlHome));
          responseMessage = 'Tornato alla pagina iniziale';
        } else if (command == 'kiosk-on') {
          final success = await startKioskMode();
          _handleStart(success);
          responseMessage = success ? 'Modalità Kiosk attivata' : 'Fallito attivazione Kiosk';
        } else if (command == 'kiosk-off') {
          final success = await stopKioskMode();
          _handleStop(success);
          responseMessage = success ?? false ? 'Modalità Kiosk disattivata' : 'Fallito disattivazione Kiosk';
        } else if (command == 'status') {
          final mode = await getKioskMode();
          responseMessage = 'Stato attuale: $mode - Ultima pagina: ${await _webViewController.currentUrl()}';
        } else if (command == 'change-pwd') {
          final body = await request.readAsString();
          final jsonBody = jsonDecode(body);
          final newPassword = jsonBody['password'] as String?;

          if (newPassword == null || newPassword.isEmpty) {
            responseMessage = 'Password non fornita o vuota';
          } else {
            await storage.write(key: 'password', value: newPassword);
            setState(() {
              _correctPassword = newPassword;
            });
            responseMessage = 'Password cambiata con successo';
          }
        } else if (command == 'url-home') {
          final body = await request.readAsString();
          final jsonBody = jsonDecode(body);
          final newUrlHome = jsonBody['url'] as String?;

          if (newUrlHome == null || newUrlHome.isEmpty || !Uri.tryParse(newUrlHome)!.isAbsolute) {
            responseMessage = 'URL non fornito, vuoto o non valido.';
          } else {
            await storage.write(key: 'urlHome', value: newUrlHome);
            setState(() {
              _urlHome = newUrlHome;
            });
            responseMessage = 'URL Home cambiato con successo a: $_urlHome';
          }
        } else if (command == 'redirect') {
          final body = await request.readAsString();
          final jsonBody = jsonDecode(body);
          final redirectUrl = jsonBody['url'] as String?;
          if (redirectUrl == null || redirectUrl.isEmpty || !Uri.tryParse(redirectUrl)!.isAbsolute) {
            responseMessage = 'URL non fornito, vuoto o non valido.';
          } else {
            await _webViewController.loadRequest(Uri.parse(redirectUrl));
            responseMessage = 'Redirezione effettuata a: $redirectUrl';
          }
        } else {
          responseMessage = 'Comando non riconosciuto: $command';
        }

        _addLog('[$now] Comando "$command" eseguito: $responseMessage');

        return Response.ok(
          jsonEncode({
            'status': 'success',
            'command': command,
            'message': responseMessage,
            'timestamp': now.toIso8601String(),
            'current_url': await _webViewController.currentUrl(),
            'kiosk_mode': await getKioskMode().then((mode) => mode.toString()),
            'is_launcher': _isLauncherDefault,
          }),
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Origin, Content-Type',
          },
        );
      } catch (e) {
        final errorMessage = 'Errore durante l\'esecuzione del comando: $e';
        _addLog('[$now] $errorMessage');

        return Response.internalServerError(
          body: jsonEncode({
            'status': 'error',
            'command': command,
            'message': errorMessage,
            'timestamp': now.toIso8601String(),
          }),
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Origin, Content-Type',
          },
        );
      }
    }

    _server = await serve(handler, '0.0.0.0', _serverPort);
    _addLog('Server in ascolto su http://$_serverIp:${_server!.port}');
  }

  void _handleStart(bool didStart) {
    if (!didStart && Platform.isIOS) {
      _addLog(_unsupportedMessage);
    } else {
      _addLog('Modalità Kiosk attivata');
    }
  }

  void _handleStop(bool? didStop) {
    if (didStop == false) {
      _addLog('Impossibile disattivare la modalità kiosk');
    } else {
      _addLog('Modalità Kiosk disattivata');
    }
  }

  Future<void> _generateDeviceId() async {
    // Usa l'ID del dispositivo se disponibile, altrimenti genera un UUID
    try {
      _deviceId = await const MethodChannel('flutter.deviceInfo').invokeMethod('getDeviceId');
    } catch (e) {
      _deviceId = 'webview-${DateTime.now().millisecondsSinceEpoch}';
    }
    await storage.write(key: 'deviceId', value: _deviceId);
  }

  @override
  void dispose() {
    _server?.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<KioskMode>(
      stream: watchKioskMode(),
      builder: (context, snapshot) {
        final mode = snapshot.data;
        final isKioskEnabled = mode == KioskMode.enabled;
        /*if (!isKioskEnabled) {
          startKioskMode();
        }*/
        return Stack(
          children: [
            if (_isWebViewInitialized)
              Positioned.fill(
                child: WebViewWidget(
                  controller: _webViewController,
                ),
              )
            else
              const Center(
                child: CircularProgressIndicator(),
              ),

            if (_isWebViewInitialized && _isWebViewLoading)
              const Center(
                child: CircularProgressIndicator(),
              ),

            if (_showPanel)
              GestureDetector(
                behavior: HitTestBehavior.translucent,
                onTap: () {
                  setState(() {
                    _showPanel = false;
                  });
                },
              ),

            // Mostra l'icona solo se la modalità kiosk non è attiva
            if (!isKioskEnabled)
              Positioned(
                left: 20,
                bottom: 20,
                child: GestureDetector(
                  onTap: () {
                    setState(() {
                      _showPanel = !_showPanel;
                    });
                  },
                  child: Container(
                    padding: const EdgeInsets.all(12),
                    decoration: const BoxDecoration(
                      color: Colors.blue,
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.settings,
                      color: Colors.white,
                    ),
                  ),
                ),
              ),

            if (_showPanel)
              Positioned(
                bottom: 20,
                left: 0,
                right: 0,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 20),
                      child: Card(
                        elevation: 8,
                        child: Padding(
                          padding: const EdgeInsets.all(8.0),
                          child: Column(
                            children: [
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                                children: [
                                  FloatingActionButton(
                                    heroTag: 'btn1',
                                    onPressed: mode == KioskMode.disabled
                                        ? () => startKioskMode().then(_handleStart)
                                        : null,
                                    child: const Icon(Icons.lock),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 8),
                              Text(
                                isKioskEnabled
                                    ? 'Modalità attuale: Kiosk attivo'
                                    : 'Modalità attuale: Kiosk disattivo',
                                style: Theme.of(context).textTheme.bodySmall,
                              ),
                              const SizedBox(height: 8),
                              Text(
                                'Server: http://$_serverIp:$_serverPort\n'
                                    'Ultimo comando: $_lastCommand\n'
                                    'Ricevuto: ${_lastCommandTime?.toLocal() ?? 'Mai'}\n'
                                    'Console:\n${_logs.reversed.take(3).join('\n')}'
                                    ,
                                style: Theme.of(context).textTheme.bodySmall,
                                textAlign: TextAlign.center,
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
          ],
        );
      },
    );
  }
}

const _unsupportedMessage = '''
Single App mode è supportato solo per dispositivi gestiti 
con Mobile Device Management (MDM) e l'app deve essere 
abilitata per questa modalità dal MDM.
''';